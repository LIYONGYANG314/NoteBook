# 完全二叉搜索树

## 算法

与之联系的是一道PAT上1064的题，它给出了组成二叉树的节点权值，让输出完全二叉树的层序遍历。

要点就是，完全二叉树可以用数组存储，而且二叉搜索树的先序遍历一定是一个递增数列。

此类问题就先把得到的数据进行排序得到二叉搜索树的先序遍历。然后对于这个完全二叉搜索树可以先开一个数组来存它。注意现在开的数组里面并没有什么数据，但是我依然可以按照一颗二叉搜索树来看待它，也就是这颗树没有内容但是存储空间就在那里。所以我们要做的是对这颗空树进行先序遍历，都知道这样先序遍历就是遍历他的空间，这样就可以和之前存的先序遍历结果相对应起来。之前排序的数据记录了先序遍历一次遍历到的内容，后面对存储空间的先序遍历是先序遍历过程所要经历的空间，而遍历到一个节点所要做的就是把内容写进去就行了。

然后最后得到一个结果存在数组里，那么还要层序遍历吗？完全不用，因为数组对于完全二叉树的存储就是按照层来的。

还有一点，完全二叉树的左子树应该是该节点的位置n进行如下运算：$n\times2$（左子树节点位置）$n\times2+1$（右子树节点位置）

## 代码

```c
#include <stdio.h>
#include <algorithm>
using namespace std;
int data[2001], CST[2001], s = 1, N;
bool cmp(int a, int b){
    return a < b;
}
void Inorder(int r){
    if(r >= N) return;
    Inorder(r * 2);
    CST[r] = data[s++];
    Inorder(r * 2 + 1);
}
int main(){
    scanf("%d", &N);
    N += 1;
    for(int i = 1; i < N; i++){
        scanf("%d", &data[i]);
    }
    sort(data+1, data+N, cmp);
    Inorder(1);
    printf("%d", CST[1]);
    for(int i = 2; i < N; i++){
        printf(" %d", CST[i]);
    }
    printf("\n");
    return 0;
}

```

