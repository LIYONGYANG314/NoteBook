# 最短路径算法

## 无权单源最短路算法

需要先初始化`dist`（表示的是当前点到原点的距离）所有值为`-1`，初始化`path`（存储路径，即标明了当前点的前一个点是多少）所有值为`-1`，找到原点`s`，取`dist[s] = 0`

```c
void Unweignted (node S){
  Enqueue(S, Q)// 把S入队列
  while(!IsEmpty(Q)){
    V = Dequeue(Q);
    for(V 的每一个邻接点 W){
      if(dist[W] = -1){// 表示该节点还没有被遍历过
        dist[W] = dist[V] + 1;
        path[W] = V;// 知道了W的前一个节点是V
        Enqueue(W, Q);
      }
    }
  }
}
```

## Dijkstra算法

初始时`dist`每一位为正无穷`path`每一位为`-1`。

```c
void Dijkstra(){
    while(1){
        V = 为收录顶点中dist最小者;// 也就是collected中值为false的点中具有最小距离的点
        if(这样的V不存在) break;
        collected[V] = true; // 表示这个点已经被遍历过了
        for( V的每一个邻接点W ){
            // 下面的判断可能没有太大需要，因为一个点如果被遍历了，那么它存留的最短路径在当前来说一定是会小于dist[V]+E的，因为W如果被遍历过，那么W就是在V之前被遍历，其最短径长度必然小于V，更不用说还要加上一个E了，所以if(dist[V]+E<v,w> < dist[W])完全足够。
            if(collected[W] == false){
                if(dist[V]+E<v,w> < dist[W]){// 如果邻接点通过V到达原点的距离更小，那么就更新现在的邻接点到原点的距离值
                    dist[W] = dist[V] + E<v,w>;
                    path[W] = V;
                }
            }
        }
    }
}
```

## 多源最短径Floyd算法

开始的初始化不可达的两点之间存$+\infty$

```c
void Floyd(){
    for(i = 0; i < N; i++)
        for(j = 0; j < N; j++){
            D[i][j] = G[i][j];
            path[i][j] = -1;
        }// 初始化部分得到邻接图D，路径数组path
    for( k = 0; k < N; k++)
        for(i = 0; i < N; i++){
            for(j = 0; j < N; i++)//这样的循环会先探寻相隔较近的两个点看有没有可能通过添加一个点而改变他们之间的距离。之后扩展到相隔较远的点这个时候由于前期的更新已经使得相隔较远的点也能被k的加入而变得可以连接，所以能以此得到最短的路径。
                //比如一开始有两个点1、2是并不相连的，但是当有了k = 3的加入，1、4通过1、3、4连接了起来，所以1、4之间的值不再是无穷大了，那么又由于4与2相连，所以有了4的加入，1，2也会相连，那么循环完成的就是这么个过程，后面的可连通性也来源于之前循环的工作。
                if(D[i][k] + D[k][j] < D[i][j]) {
                    D[i][j] = D[i][k] + D[k][j];
                    path[i][j] = k;// 表示由i->j中间需要k，那自然在打印i，j之间的最短路径时候就需要先找到path中的ij位，发现指向k，然后找ik又发现。。。依此类推直到在一个ik处存的是-1，那么就找到了
                }
        }
}
```

