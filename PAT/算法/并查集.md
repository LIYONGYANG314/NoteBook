# 并查集

## 初始化

初始的时候每个节点的父亲节点就是自己

```c
int p[100];
for(int i = 0; i < 100; i++){
  p[i] = i;
}
```

## Find操作

找到输入节点x的根节点

```c
int find(int x)
{
  if(p[x] == x) return x;
  return p[x] = find(p[x]);
}
```

对于上面的过程是先放入要判断的x，当`p[x] == x`说明的是该点的父节点是他自己，只有根节点是这样的，所以直接返回`x`，而递归层层返回的`x`都被赋值给了`p[x]`，这样做相当于这一路的递归遍历到的所有节点的父节点都会是根节点，这么做方便之后直接能比较两个点是否属于一个集合。

## Unite操作

```c
void Unite(int x1, int x2) 
{
    int p1 = find(x1);
    int p2 = find(x2);
    p[p1] = p2;
}
```

一个根节点的父亲改为另一个根节点，于是两棵树就被连在一起。

## 注意

之前在做PAT 1034的时候发现了一个误区，那就是总以为经过Unit过后所有的子节点但凡有关联就会指向同一个父亲。这种想法是错的。为什么会有这种想法，是因为之前觉得在Find的时候递归层层返回会使得遍历到的所有部分都把自己的父亲设为根上的那个父亲。这种想法没错，的确是这样，但是忽略了一点，当我们进行合并操作时是先合并后操作，如果说最后一次的合并是两个不同的集合，那么出现的情况就会是一个头头认另一个头头为父亲但是他的子孙却不会。所以这种情况下同一个集合的节点他们的父亲为两个，尽管这个集合的任一节点通过Find可以找到根上的父亲，但是有时候不会再做Find而是直接观察P集合找父亲个数确定集合数了，那么这个时候同一集合却指着不同父亲，必然会出问题，所以最好的解决办法是对所有的节点再进行一次Find赋值，保证所有同集合的节点都指向同一个父亲。