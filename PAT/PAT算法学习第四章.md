# PAT算法学习第四章

## Day 1

### 基础篇：

- 不要再一个程序中同时使用`cout`和`printf`
- `long long`型变量赋值时：`long long N = 123456789012345LL`
- 碰到浮点数类型都应该使用`double`来存储(注：`%lf`输出)
- 字符：`' '`，字符串：`" "`
- `bool`：1、0
- `#define 标识符 常量` 结尾无分号。常量中打括号是为了保证`a = b + 1`这种情况下`(b + 1)`能先在一起求和
- `A ? B : C`A为真，值为B，A为假，值为C
- `>> <<`二进制移位；`>= <=`可以直接用。

### 算法篇：

#### 排序

**选择排序**

1、从未排序部分`[i, n]`中选择最小元素与`i`交换位置，于是前`[0, i]`就是有序的序列了。

2、遍历n次即可将上面n+1个数进行完全排序。

```c
void selectSort() {
  for(int i = 0; i < n-1; i++){
    int k = i;
    for(int j = i+1; j < n; j++){
      if(A[j] < A[k]){
        k = j;
      }
    }
    int temp = A[i];
    A[i] = A[k];
    A[k] = temp;
  }
}
```

**插入排序**

1、序列分为两部分，一边有序一边没序。

2、从无序选择一个元素添加到有序序列，使序列仍然有序。

```c
int A[maxn], n;
void insertSort() {
  for(int i = 1 i <= n; i++){
    int temp = A[i], j = i;
    while(j > 0&& temp < A[j-1]){
      A[j] = A[j - 1];
      j--;
    }
    A[j] = temp;
  }
}
```

**使用C++的`sort()`函数**

```c++
#include <stdio.h>
#include <algorithm>
using namespace std

sort(首元素地址(必填), 尾元素地址的下一个地址(必填), 比较函数(非必填)); //就是包头不包尾
//不用a = sort(), 直接写地址的时候就已经满足赋值条件了 sort(a, a+7)对a - a+6这7个值排序

bool cmp(a, b)//一定要注意a b的顺序 这么写就指明了一个顺序 a在前b在后，如果我是要按由大到小的顺序排列，那么return a > b 因为当a大于b时，返回的是true所以a在前b在后可以被打印出来
```

### 英语生单词：

`simultaneously`：同步地，同时地

`merge`：合并，融合，汇总

## Day 2

### 基础篇：

- `long long`——`%lld`、`double`——`%lf`
- `%c`在`scanf`里可以读出空格，所以这种时候没办法将空格作为截止的标识
- `%md`不足m位时，以空格补足高位按m位输出；`%.mf`保留小数点后m位数字；`%0md`不足m位时，以0补足m位输出
- `getchar()`会读换行符
- 常用的`math.h`函数：
  - `fabs()`：`double`型变量取绝对值
  - `floor()&ceil()`：用于`double`的向下取整和向上取整
  - `pow(), sqrt(), log(), sin(), asin(), round()`：都是对double进行乘方，开方，自然对数，三角函数，反三角函数，四舍五入。
- 字符串的读取，一般使用`scanf("%[^\n]", S)`，表示的意思是读到`\n`换行结束，但是那个回车符号不会被读取，所以需要使用`getchar()`来读取最后的空格，不然后面的字符都会读到这回车，但他们都不读取，然后什么都没读就结束读取了，造成数据无法进来。但是对于scanf(%s)则没有这样的影响，它只对于结尾处的回车换行或者空格有响应，而对于开始的回车空格不会读取。但是`%[^\n]`则不同，它会读到换行作为结束，但是不会读取这个字符，这个字符不依靠其它的东西取出的话一直留在缓冲流中，一直让后面的东西不停结束。**总结起来需要记住：`%[^\n]`需要使用getchar取出每行最后的换行符，但是%s对于打头的空格和回车都不会读入。**`a = getcahr()`
- `strupr(),strlowr()_______(string.h)     tolower(),touper(),isupper(),islower()______________(ctype.h)`

### 算法篇：

#### 散列

定义：元素通过一个函数转换成整数，使得该整数可以尽量唯一地代表该元素

对于字符串可以把它看成26进制数来解决。

可以调用`map()`函数去做。头文件是`#include <map>`

`map<char, int>::iterator it`迭代器用`mp.find('key')`赋值，`erase`可以单个或是多个元素删除，以`it`来删，`clear()`清除所有的元素，`size`获取映射的大小。**map**会依据键值由小到大排序，`mp.find()`如果有该元素，那么会返回迭代器，如果没有的话那么就返回`mp.end()`，使用`mp.count()`，返回的是被查找元素的个数。如果有，返回1；否则，返回0。`it&mp`都是两个元素`first`(key值)和`second`(值)。`unordered_map`是没有排序需要的map，速度更快。

## Day 3

### 基础篇：

- ```c
  switch(a){
    case a表达式:
      ...;
      break;
    default:
      ...;
  }
  ```